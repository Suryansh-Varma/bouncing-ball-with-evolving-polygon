<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polygon Bounce Simulation</title>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        canvas {
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 20px;
        }
        button:hover {
            background-color: #45a049;
        }
        .info {
            font-size: 18px;
            margin-bottom: 10px;
        }
        #oopsMessage {
            font-size: 32px;
            color: #e74c3c;
            font-weight: bold;
            margin: 20px 0;
            text-align: center;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Polygon Bounce Simulation</h1>
    <div class="info">Sides: <span id="sideCount">5</span></div>
    <div id="oopsMessage">Oops! The ball has left the play! ü§™</div>
    <canvas id="canvas" width="600" height="600"></canvas>
    <button id="restartBtn">Restart Simulation</button>

    <script>
        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const sideCountDisplay = document.getElementById('sideCount');
        const restartBtn = document.getElementById('restartBtn');
        const oopsMessage = document.getElementById('oopsMessage');
        
        // Speech synthesis
        const synth = window.speechSynthesis;
        
        // Polygon names
        const polygonNames = [
            "", "", "", "", "",
            "Pentagon", "Hexagon", "Heptagon", "Octagon", "Nonagon", "Decagon",
            "Hendecagon", "Dodecagon", "Tridecagon", "Tetradecagon", "Pentadecagon",
            "Hexadecagon", "Heptadecagon", "Octadecagon", "Enneadecagon", "Icosagon"
        ];
        
        // Simulation parameters
        let sides = 5;
        let radius = 200;
        let centerX = canvas.width / 2;
        let centerY = canvas.height / 2;
        let ballRadius = 15;
        let ballX = centerX;
        let ballY = centerY - 100;
        let ballSpeedX = 3;
        let ballSpeedY = 4;
        let vertices = [];
        let lastEdgeHit = -1;
        let animationId;
        let gameActive = true;
        let escapeTimer = 0;
        const escapeInterval = 300; // frames before possible escape
        
        // Funny escape messages
        const escapeMessages = [
            "Whoops! The ball escaped! üòÖ",
            "Ball: I'm outta here! üèÉ‚Äç‚ôÇÔ∏è",
            "The ball has left the building! üö™",
            "Ball.exe has stopped working üí•",
            "The ball decided to retire early üèñÔ∏è",
            "Ball: This polygon is too small for me! üöÄ",
            "The ball went to get milk... ü•õ",
            "Ball has achieved freedom! üóΩ",
            "The ball is on strike! ‚úä",
            "Ball: I need some me time üßò‚Äç‚ôÇÔ∏è"
        ];
        
        // Initialize the simulation
        function init() {
            sides = 5;
            lastEdgeHit = -1;
            ballX = centerX;
            ballY = centerY - 100;
            ballSpeedX = 3 + Math.random() * 2;
            ballSpeedY = 4 + Math.random() * 2;
            updateVertices();
            sideCountDisplay.textContent = sides;
            gameActive = true;
            oopsMessage.style.display = 'none';
            escapeTimer = 0;
            speakPolygonName();
            draw();
        }
        
        // Update polygon vertices
        function updateVertices() {
            vertices = [];
            for (let i = 0; i < sides; i++) {
                const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                vertices.push({x, y});
            }
        }
        
        // Speak the polygon name
        function speakPolygonName() {
            if (synth.speaking) {
                synth.cancel();
            }
            
            const name = sides < 5 ? "Polygon" : 
                        sides <= 20 ? polygonNames[sides] : 
                        sides + "-sided Polygon";
            
            const utterance = new SpeechSynthesisUtterance(name);
            utterance.rate = 0.9;
            synth.speak(utterance);
        }
        
        // Speak funny message
        function speakFunnyMessage() {
            if (synth.speaking) {
                synth.cancel();
            }
            
            const funnyMessages = [
                "Oops! The ball escaped!",
                "Oh no! The ball is gone!",
                "The ball has left the polygon!",
                "Bye bye ball!",
                "The ball is out of here!"
            ];
            
            const message = funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.rate = 1.1;
            utterance.pitch = 1.3;
            synth.speak(utterance);
        }
        
        // Draw the scene
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw polygon
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (gameActive) {
                // Draw ball
                ctx.beginPath();
                ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.strokeStyle = '#c0392b';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw polygon name
            ctx.font = '24px Comic Sans MS';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#333';
            const name = sides < 5 ? "Polygon" : 
                          sides <= 20 ? polygonNames[sides] : 
                          sides + "-sided Polygon";
            ctx.fillText(name, centerX, centerY);
            
            // Draw side count
            ctx.font = '18px Comic Sans MS';
            ctx.fillText(`Sides: ${sides}`, centerX, centerY + 30);
        }
        
        // Check if ball is inside polygon
        function isPointInPolygon(x, y) {
            let inside = false;
            for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                const xi = vertices[i].x, yi = vertices[i].y;
                const xj = vertices[j].x, yj = vertices[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // Check collision with edges
        function checkCollisions() {
            // Random chance to escape (after some time)
            escapeTimer++;
            if (escapeTimer > escapeInterval && Math.random() < 0.005) {
                // Make the ball escape dramatically
                ballSpeedX *= 5;
                ballSpeedY *= 5;
            }
            
            // Check if ball has escaped
            if (!isPointInPolygon(ballX, ballY)) {
                gameActive = false;
                oopsMessage.textContent = escapeMessages[Math.floor(Math.random() * escapeMessages.length)];
                oopsMessage.style.display = 'block';
                speakFunnyMessage();
                cancelAnimationFrame(animationId);
                return;
            }
            
            for (let i = 0; i < vertices.length; i++) {
                const p1 = vertices[i];
                const p2 = vertices[(i + 1) % vertices.length];
                
                // Vector from p1 to p2
                const edgeX = p2.x - p1.x;
                const edgeY = p2.y - p1.y;
                
                // Vector from p1 to ball
                const ballToP1X = ballX - p1.x;
                const ballToP1Y = ballY - p1.y;
                
                // Project ball position onto edge
                const edgeLength = Math.sqrt(edgeX * edgeX + edgeY * edgeY);
                const unitEdgeX = edgeX / edgeLength;
                const unitEdgeY = edgeY / edgeLength;
                const projectionLength = ballToP1X * unitEdgeX + ballToP1Y * unitEdgeY;
                
                // Closest point on edge to ball
                let closestX, closestY;
                if (projectionLength < 0) {
                    closestX = p1.x;
                    closestY = p1.y;
                } else if (projectionLength > edgeLength) {
                    closestX = p2.x;
                    closestY = p2.y;
                } else {
                    closestX = p1.x + projectionLength * unitEdgeX;
                    closestY = p1.y + projectionLength * unitEdgeY;
                }
                
                // Distance from ball to closest point on edge
                const distanceX = ballX - closestX;
                const distanceY = ballY - closestY;
                const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                
                // Collision detected
                if (distance < ballRadius) {
                    // Only add a new side if this is a new edge hit
                    if (lastEdgeHit !== i) {
                        lastEdgeHit = i;
                        sides++;
                        updateVertices();
                        sideCountDisplay.textContent = sides;
                        speakPolygonName();
                    }
                    
                    // Calculate reflection
                    const normalX = distanceX / distance;
                    const normalY = distanceY / distance;
                    
                    const dotProduct = ballSpeedX * normalX + ballSpeedY * normalY;
                    ballSpeedX = ballSpeedX - 2 * dotProduct * normalX;
                    ballSpeedY = ballSpeedY - 2 * dotProduct * normalY;
                    
                    // Move ball outside collision range
                    const overlap = ballRadius - distance;
                    ballX += normalX * overlap * 1.1;
                    ballY += normalY * overlap * 1.1;
                    
                    return;
                }
            }
        }
        
        // Update simulation
        function update() {
            if (!gameActive) return;
            
            // Move ball
            ballX += ballSpeedX;
            ballY += ballSpeedY;
            
            // Check collisions
            checkCollisions();
            
            // Draw
            draw();
            
            // Continue animation if game is still active
            if (gameActive) {
                animationId = requestAnimationFrame(update);
            }
        }
        
        // Start the simulation
        function startSimulation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            init();
            update();
        }
        
        // Event listeners
        restartBtn.addEventListener('click', startSimulation);
        
        // Start the simulation
        startSimulation();
    </script>
</body>
</html>